/*
    Function changes 
        1. expected_arrival_time for all stops in a task object for a given task id
        2. expected_start_time and expected_end_time for all runs for a given task id
        3. expected_arrival_time for all stops in all runs for a given task id
*/

var AWS = require("aws-sdk");
AWS.config.update({
    region: "us-east-1"
});

var dailyTasksTableName = process.env.DAILY_TASKS_TABLE_NAME;
var dailyRunsTableName = process.env.DAILY_RUNS_TABLE_NAME;
var dailyStopsTableName = process.env.DAILY_STOPS_TABLE_NAME;

// Queue URL to send message to
var queueURL = process.env.QUEUE_URL;
console.log('QueueURL: ', queueURL);

var sqsClient = new AWS.SQS({
    apiVersion: "2012-11-05"
});

var dynamodb = new AWS.DynamoDB({apiVersion: '2012-08-10'});
var fromDynamoDbJson = AWS.DynamoDB.Converter.output;
var toDynamoDbJson = AWS.DynamoDB.Converter.input;

exports.handler = (event, context, callback) => {
    console.log("Event: " + JSON.stringify(event));
    var error = null;
    updateTask(event.adiona_daily_task_id, event.change_offset, (updateTask_err) => {
        if (updateTask_err) {
            console.log("couldn't update time change for task: " + event.adiona_daily_task_id);
            callback(updateTask_err, false);
        }
        else {
            getRuns(event.adiona_daily_task_id, (runs_err, runs) => {
                if (runs_err) {
                    console.log("couldn't get runs for task: " + event.adiona_daily_task_id);
                    callback(runs_err, false);
                }
                else {
                    runs = runs ? runs : [];
                    runs.forEach((run) => {
                        queueCascadeChangeRequest({
                            action: "CascadeToRun",
                            subAction: "ChangeStartTime",
                            payload: {
                                adiona_daily_run_id: run.adiona_daily_run_id,
                                changeOffset: event.change_offset
                            }
                        });
                    });
                    
                    getStops(event.adiona_daily_task_id, (stops_err, stops) => {
                        if (stops_err) {
                            console.log("could't get stops for task: " + event.adiona_daily_task_id);
                            callback(stops_err, false);
                        }
                        else {
                            stops = stops ? stops.filter(st => st.stop_template_id != 1 && st.stop_template_id != 0) : [];
                            stops.forEach((stop) => {
                                queueCascadeChangeRequest({
                                    action: "CascadeToStop",
                                    subAction: "ChangeStartTime",
                                    payload: {
                                        adiona_daily_stop_id: stop.adiona_daily_stop_id,
                                        changeOffset: event.change_offset
                                    }
                                });
                            });
                            
                            callback(null, true);
                        }
                    });
                }
            });
        }
    });
};

function queueCascadeChangeRequest(request) {
    return new Promise((resolve, reject) => {
        sqsClient.sendMessage({
            DelaySeconds: 0,
            QueueUrl: queueURL,
            MessageBody: JSON.stringify(request)
        }, (err, data) => {
            if (err) {
                console.log(err, err.stack);
                reject(err);
            }
            else {
                console.log(data);
                resolve(data);
            }
        });
    });
}

function updateTask(adiona_daily_task_id, change_offset, callback) {
    console.log("adiona_daily_task_id: " + adiona_daily_task_id);
    var error = null;
    var task = null;
    var getTaskParams = {
      Key: {
       "adiona_daily_task_id": toDynamoDbJson(adiona_daily_task_id)
      }, 
      TableName: dailyTasksTableName,
      ConsistentRead: true
    };
    console.log("GetTaskQueryParams: " + JSON.stringify(getTaskParams));
    dynamodb.getItem(getTaskParams, function(err, data) {
        if (err) { 
            console.log(err, err.stack);
            error = err;
            callback(err, null);
        }
        else if (!data.Item) {
            error = "no task found";
            console.log(error);
            callback(error, null);
        }
        else {
            task = fromDynamoDbJson({ "M": data.Item });
            if (task != null) {
                var ridx = 0;
                var idx = 1;
                var expr = "";
                var exprAttrVals = {};
                task.runs.forEach((run) => {
                   var sidx = 0;
                   run.stops.forEach((stop) => {
                       expr = expr + `, runs[${ridx}].stops[${sidx}].expected_arrival_time = :expected_arrival_time${idx}`;
                       exprAttrVals[`:expected_arrival_time${idx}`] = toDynamoDbJson(offsetDate(stop.expected_arrival_time, change_offset));
                       sidx++;
                       idx++;
                   });
                   ridx++;
                });
                
                expr = expr.substr(1);
                
                var params = {
                    Key: {
                        "adiona_daily_task_id": toDynamoDbJson(adiona_daily_task_id)
                    },
                    TableName: dailyTasksTableName,
                    UpdateExpression: "SET " + expr,
                    ExpressionAttributeValues: exprAttrVals
                };
                
                console.log("UpdateTaskParams: " + JSON.stringify(params));
                dynamodb.updateItem(params, function(err, data) {
                    if (err) { 
                        console.log(err, err.stack);
                        callback(err, null);
                    }
                    else {
                        callback(null, data);
                    }
                });
            }
        }
    });
}

function getRuns(adiona_daily_task_id, callback) {
    console.log("adiona_daily_task_id: " + adiona_daily_task_id);
    var params = {
      ExpressionAttributeValues: {
       ":adiona_daily_task_id": toDynamoDbJson(adiona_daily_task_id)
      }, 
      KeyConditionExpression: "adiona_daily_task_id = :adiona_daily_task_id", 
      TableName: dailyRunsTableName,
      IndexName: "adiona_daily_task_id-index"
    };
     
    console.log("GetRunsQueryParams: " + JSON.stringify(params));
    dynamodb.query(params, function(err, data) {
        if (err) { 
            console.log(err, err.stack);
            callback(err, null);
        }
        else {
            var runs = [];
            data.Items.forEach((dynamodbRun) => {
                var run = fromDynamoDbJson({ "M": dynamodbRun });
                runs.push(run);
            });
            callback(null, runs);
        }
    });
}

function getStops(adiona_daily_task_id, callback) {
    var params = {
      ExpressionAttributeValues: {
       ":adiona_daily_task_id": toDynamoDbJson(adiona_daily_task_id)
      }, 
      KeyConditionExpression: "adiona_daily_task_id = :adiona_daily_task_id", 
      TableName: dailyStopsTableName,
      IndexName: "adiona_daily_task_id-index"
     };
     
    console.log("GetStopsQueryParams: " + JSON.stringify(params));
    dynamodb.query(params, function(err, data) {
        if (err) { 
            console.log(err, err.stack);
            callback(err, null);
        }
        else {
            var stops = [];
            data.Items.forEach((dynamodbStop) => {
                var stop = fromDynamoDbJson({ "M": dynamodbStop });
                stops.push(stop);
            });
            callback(null, stops);
        }
    });
}

function offsetDate(utcDateStr, change_offset) {
    var utcDate = new Date(utcDateStr + "Z"); // UTC Date
    var totalMilliseconds = utcDate.getTime() + change_offset * 60000;
    utcDate = new Date(totalMilliseconds);
    var utcDateIsoStr = utcDate.toISOString();
    utcDateIsoStr = utcDateIsoStr.replace("T", " ");
    utcDateIsoStr = utcDateIsoStr.substr(0, 19);
    return utcDateIsoStr;
}